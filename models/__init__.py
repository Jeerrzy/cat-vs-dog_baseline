#!/usr/bin/env python
# -*- coding:utf-8 -*-
# @date: 2023/8/26
# @folder: models
# @author: jeerrzy


"""
说明
    - models 用来存放定义模型的文件
        - lenet-5.py 著名lenet-5神经网络模型示例
        - my_diy_net.py 如何编写自定义模型的示例
        - trainer.py 封装训练过程的训练器
        - predictor.py 封装预测过程的预测器

    - 添加自定义的模型时, 请在本文件夹下添加xxx.py, 然后在get_model()函数里拓展，以保证查阅方便和结构规范


注意
    - 定义模型时请注意, 模型深度、卷积核尺寸、单元和结构等适合自由发挥, 但有两点必须要做到匹配：
        1.输入张量的尺寸要和输入层 以及网络结构相匹配。例如, 在采用一些特殊大小的卷积核时, 输入尺度必须为特定数字的倍数, 否则计算就会出错。
        然而, 输入图片的长和宽是不固定的。实践中的通常做法是直接将原图reshape到设定好的输入尺寸, 然后再输入到网络里。
        因此, 设定的输入尺寸input_shape[h, w]成了一个重要的超参。一般来说, 该尺寸越小, 模型速度越快, 但精度越低, 反之速度越慢, 但精度越高。

        2.输出层的通道数必须要和任务希望得到的信息维度匹配:
        (可以仔细思考一下原因。神经网络是从监督信息的结果出发去拟合模型, 所以模型输出的信息维度必须先和输出信息维度匹配上。
        在匹配的前提下，其次应该考虑如何设计衡量指标和损失函数。最后才是考虑模型的结构和设计技巧问题。)

        对于多分类任务, 最常见的做法是让输出通道数直接等于要分类的类别数, 然后让每个通道去匹配一个类别的概率值。
        由于猫和狗是二分类, 所以输出通道数为2, 我们会默认规定一个次序, 例如猫是第一个通道, 狗是第二个通道。
            self.output_fc = nn.Linear(..., 2)
        在训练时, 使用交叉熵损失函数(CE Loss)计算多分类损失。
        在训练完毕, 执行预测时, 使用softmax计算概率, 然后用argmax取所有通道中概率值最大的那个通道, 作为输出类别结果。

        上述是最常见的思路, 手写数字实验使用了这种方法, 示例文件中采用的也是这种方法。
        但其实还可能存在另一种思路, 那就是将猫狗分类看作一维信息, 只输出一个通道的数值: 
            self.output_fc = nn.Linear(..., 1)
        为了将该通道的值转化到0-1之间的概率值, 通常会使用sigmoid激活函数:
            prob = nn.Sigmoid(output)
        然后可以规定, 若prob<0.5, 则判定为猫, 若prob>=0.5, 则判定为狗。然后使用二分类交叉熵函数(BCE loss)计算损失。

        相比较上一种方法, 这种方法的特点在于, 它让模型天然就理解了"猫和狗是一组互斥且相加概率为1的类别"这个关键信息, 
        因此每当提取到"猫"的特征时, 在提升判定为"猫"的概率时, 模型会自发地抑制判定为"狗"的概率。反之亦然。
        如果从这个角度理解, 这种方法在处理二分类问题时可能会更占优势。
        上一种方法不是这样。可以想象, 由于是每种类别一个通道, 它实际上是让模型分别看图片是"有多像猫"和"有多像狗", 然后取"更像"的那个。
        但可以设想, 假如类别比较多, 如十个类别, 那么每个类别的取值范围就只有0.1, 对数值变化过于敏感, 将会导致误差很大。
        仅仅是一个输出通道数是1还是2的不同, 就会造成很大影响。这个栗子可以证明神经网络的设计具有很强的技巧性, 并非只有"炼丹"的暴力和简单。

        第二种方法示例代码中没有给出, 支持学有余力的同学分别尝试并给出对比实验的分析
"""


from models.lenet import LeNet


def get_model(model_name):
    """
    :param model_name: 定义的模型名
    :return: 模型类
    """
    if model_name == 'lenet-5':
        return LeNet

    # 自定义的模型请在此补充
    # elif model_name == 'my_diy_net':
    #     return MyDIYNet
    # ...
    # ...

